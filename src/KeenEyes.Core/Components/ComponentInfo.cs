using System.Runtime.CompilerServices;

namespace KeenEyes;

/// <summary>
/// Runtime metadata for a registered component type within a specific World.
/// </summary>
public sealed class ComponentInfo
{
    /// <summary>Unique identifier for this component type within the owning World.</summary>
    public ComponentId Id { get; }

    /// <summary>The CLR type of this component.</summary>
    public Type Type { get; }

    /// <summary>Size of the component in bytes. Zero for tag components.</summary>
    public int Size { get; }

    /// <summary>Whether this is a tag component (zero-size marker).</summary>
    public bool IsTag { get; }

    /// <summary>
    /// The schema version of this component for migration support.
    /// Default is 1 for components that don't specify a version.
    /// </summary>
    public int Version { get; internal set; } = 1;

    /// <summary>The name of the component type.</summary>
    public string Name => Type.Name;

    /// <summary>
    /// Delegate that fires ComponentAdded events with boxed data for this component type.
    /// Created lazily on first entity creation with this component type.
    /// This avoids per-handler lambda allocations while maintaining type safety.
    /// </summary>
    internal Action<Events.ComponentEventHandlers, Entity, object>? FireAddedBoxed { get; set; }

    /// <summary>
    /// Setup function that initializes FireAddedBoxed delegate.
    /// Stored once per component type during registration, avoiding reflection in entity creation.
    /// </summary>
    internal Action<ComponentInfo, Events.ComponentEventHandlers>? SetupDispatcher { get; set; }

    /// <summary>
    /// Factory delegate that creates a FixedComponentArray for this component type.
    /// Enables AOT-compatible chunk creation without reflection.
    /// </summary>
    internal Func<int, IComponentArray>? CreateComponentArray { get; set; }

    /// <summary>
    /// Delegate that applies this component (boxed) to an entity builder using With&lt;T&gt;.
    /// Enables AOT-compatible prefab application without reflection.
    /// </summary>
    internal Action<EntityBuilder, object>? ApplyToBuilder { get; set; }

    /// <summary>
    /// Delegate that applies this component as a tag to an entity builder using WithTag&lt;T&gt;.
    /// Enables AOT-compatible prefab application without reflection.
    /// </summary>
    internal Action<EntityBuilder>? ApplyTagToBuilder { get; set; }

    /// <summary>
    /// Delegate that invokes a custom validator for this component type.
    /// Enables AOT-compatible validation without reflection.
    /// </summary>
    internal Func<World, Entity, object, Delegate, bool>? InvokeValidator { get; set; }

    internal ComponentInfo(ComponentId id, Type type, int size, bool isTag)
    {
        Id = id;
        Type = type;
        Size = size;
        IsTag = isTag;
    }

    /// <inheritdoc />
    public override string ToString() => $"ComponentInfo({Name}, Id={Id.Value}, Size={Size}, IsTag={IsTag}, Version={Version})";
}

/// <summary>
/// Compile-time metadata for a component type.
/// This is generated by the source generator and contains no instance state.
/// </summary>
/// <typeparam name="T">The component type.</typeparam>
public static class ComponentMeta<T> where T : struct
{
    /// <summary>Size of the component in bytes.</summary>
    public static readonly int Size = Unsafe.SizeOf<T>();

    /// <summary>The CLR type.</summary>
    public static readonly Type Type = typeof(T);
}
