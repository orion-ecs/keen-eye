using System.Runtime.CompilerServices;

namespace KeenEyes;

/// <summary>
/// Runtime metadata for a registered component type within a specific World.
/// </summary>
public sealed class ComponentInfo
{
    /// <summary>Unique identifier for this component type within the owning World.</summary>
    public ComponentId Id { get; }

    /// <summary>The CLR type of this component.</summary>
    public Type Type { get; }

    /// <summary>Size of the component in bytes. Zero for tag components.</summary>
    public int Size { get; }

    /// <summary>Whether this is a tag component (zero-size marker).</summary>
    public bool IsTag { get; }

    /// <summary>The name of the component type.</summary>
    public string Name => Type.Name;

    /// <summary>
    /// Delegate that fires ComponentAdded events with boxed data for this component type.
    /// Created lazily on first entity creation with this component type.
    /// This avoids per-handler lambda allocations while maintaining type safety.
    /// </summary>
    internal Action<Events.ComponentEventHandlers, Entity, object>? FireAddedBoxed { get; set; }

    /// <summary>
    /// Setup function that initializes FireAddedBoxed delegate.
    /// Stored once per component type during registration, avoiding reflection in entity creation.
    /// </summary>
    internal Action<ComponentInfo, Events.ComponentEventHandlers>? SetupDispatcher { get; set; }

    internal ComponentInfo(ComponentId id, Type type, int size, bool isTag)
    {
        Id = id;
        Type = type;
        Size = size;
        IsTag = isTag;
    }

    /// <inheritdoc />
    public override string ToString() => $"ComponentInfo({Name}, Id={Id.Value}, Size={Size}, IsTag={IsTag})";
}

/// <summary>
/// Compile-time metadata for a component type.
/// This is generated by the source generator and contains no instance state.
/// </summary>
/// <typeparam name="T">The component type.</typeparam>
public static class ComponentMeta<T> where T : struct
{
    /// <summary>Size of the component in bytes.</summary>
    public static readonly int Size = Unsafe.SizeOf<T>();

    /// <summary>The CLR type.</summary>
    public static readonly Type Type = typeof(T);
}
