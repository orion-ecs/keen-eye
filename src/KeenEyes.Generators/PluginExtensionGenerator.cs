using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates C# 13 extension members on World for classes marked with [PluginExtension].
/// This allows typed property access like <c>world.Physics</c> instead of <c>world.GetExtension&lt;PhysicsWorld&gt;()</c>.
/// </summary>
[Generator]
public sealed class PluginExtensionGenerator : IIncrementalGenerator
{
    private const string PluginExtensionAttribute = "KeenEyes.PluginExtensionAttribute";

    /// <summary>
    /// KEEN005: PluginExtension property name cannot be null.
    /// </summary>
    public static readonly DiagnosticDescriptor NullPropertyName = new(
        id: "KEEN005",
        title: "PluginExtension property name cannot be null",
        messageFormat: "The property name for [PluginExtension] on '{0}' cannot be null",
        category: "KeenEyes.Usage",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "The [PluginExtension] attribute requires a non-null property name to generate the World extension property.");

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [PluginExtension] attribute
        var extensionProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                PluginExtensionAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetExtensionResult(ctx));

        // Filter valid extensions for code generation
        var validExtensions = extensionProvider
            .Where(static result => result.Info is not null)
            .Select(static (result, _) => result.Info!);

        // Collect all extensions and generate a single file
        var allExtensions = validExtensions.Collect();

        context.RegisterSourceOutput(allExtensions, static (ctx, extensions) =>
        {
            if (extensions.Length == 0)
            {
                return;
            }

            var source = GenerateWorldExtensions(extensions);
            ctx.AddSource("World.PluginExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        });

        // Report diagnostics for invalid usages
        var diagnostics = extensionProvider
            .Where(static result => result.Diagnostic is not null)
            .Select(static (result, _) => result.Diagnostic!);

        context.RegisterSourceOutput(diagnostics, static (ctx, diagnostic) =>
        {
            ctx.ReportDiagnostic(diagnostic);
        });
    }

    private static ExtensionResult GetExtensionResult(GeneratorAttributeSyntaxContext context)
    {
        // Predicate guarantees ClassDeclarationSyntax, which always has INamedTypeSymbol
        var typeSymbol = (INamedTypeSymbol)context.TargetSymbol;

        // ForAttributeWithMetadataName guarantees the attribute exists
        var attributeData = context.Attributes.First(
            a => a.AttributeClass?.ToDisplayString() == PluginExtensionAttribute);

        // Get property name from constructor argument
        if (attributeData.ConstructorArguments.Length == 0 ||
            attributeData.ConstructorArguments[0].Value is not string propertyName)
        {
            // Report error for null property name
            var diagnostic = Diagnostic.Create(
                NullPropertyName,
                context.TargetNode.GetLocation(),
                typeSymbol.Name);
            return new ExtensionResult(null, diagnostic);
        }

        // Get Nullable property from named arguments
        var isNullable = false;
        foreach (var namedArg in attributeData.NamedArguments)
        {
            if (namedArg.Key == "Nullable" && namedArg.Value.Value is bool nullable)
            {
                isNullable = nullable;
            }
        }

        var info = new ExtensionInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            propertyName,
            isNullable);

        return new ExtensionResult(info, null);
    }

    private static string GenerateWorldExtensions(ImmutableArray<ExtensionInfo> extensions)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace KeenEyes;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated extension members providing typed access to plugin extensions on World.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine("/// These extension members are generated from classes marked with <see cref=\"PluginExtensionAttribute\"/>.");
        sb.AppendLine("/// They provide convenient typed property access instead of using <see cref=\"World.GetExtension{T}\"/>.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("public static class WorldPluginExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    extension(global::KeenEyes.World world)");
        sb.AppendLine("    {");

        foreach (var ext in extensions)
        {
            var fullTypeName = ext.Namespace == "<global namespace>"
                ? ext.Name
                : $"global::{ext.FullName}";

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Gets the <see cref=\"{ext.FullName}\"/> extension from this world.");
            sb.AppendLine($"        /// </summary>");

            if (ext.IsNullable)
            {
                sb.AppendLine($"        /// <returns>The extension instance if registered; otherwise, null.</returns>");
                sb.AppendLine($"        public {fullTypeName}? {ext.PropertyName} => world.TryGetExtension<{fullTypeName}>(out var ext) ? ext : null;");
            }
            else
            {
                sb.AppendLine($"        /// <exception cref=\"global::System.InvalidOperationException\">Thrown when the extension is not registered.</exception>");
                sb.AppendLine($"        public {fullTypeName} {ext.PropertyName} => world.GetExtension<{fullTypeName}>();");
            }

            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed record ExtensionResult(ExtensionInfo? Info, Diagnostic? Diagnostic);

    private sealed record ExtensionInfo(
        string Name,
        string Namespace,
        string FullName,
        string PropertyName,
        bool IsNullable);
}
