using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates C# 13 extension members on World for classes marked with [PluginExtension].
/// This allows typed property access like <c>world.Physics</c> instead of <c>world.GetExtension&lt;PhysicsWorld&gt;()</c>.
/// </summary>
[Generator]
public sealed class PluginExtensionGenerator : IIncrementalGenerator
{
    private const string PluginExtensionAttribute = "KeenEyes.PluginExtensionAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [PluginExtension] attribute
        var extensionProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                PluginExtensionAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetExtensionInfo(ctx))
            .Where(static info => info is not null);

        // Collect all extensions and generate a single file
        var allExtensions = extensionProvider.Collect();

        context.RegisterSourceOutput(allExtensions, static (ctx, extensions) =>
        {
            if (extensions.Length == 0)
            {
                return;
            }

            var validExtensions = extensions
                .Where(e => e is not null)
                .Cast<ExtensionInfo>()
                .ToImmutableArray();

            if (validExtensions.Length == 0)
            {
                return;
            }

            var source = GenerateWorldExtensions(validExtensions);
            ctx.AddSource("World.PluginExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static ExtensionInfo? GetExtensionInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        // Get the attribute data
        var attributeData = context.Attributes.FirstOrDefault(
            a => a.AttributeClass?.ToDisplayString() == PluginExtensionAttribute);

        if (attributeData is null)
        {
            return null;
        }

        // Get property name from constructor argument
        if (attributeData.ConstructorArguments.Length == 0 ||
            attributeData.ConstructorArguments[0].Value is not string propertyName)
        {
            return null;
        }

        // Get Nullable property from named arguments
        var isNullable = false;
        foreach (var namedArg in attributeData.NamedArguments)
        {
            if (namedArg.Key == "Nullable" && namedArg.Value.Value is bool nullable)
            {
                isNullable = nullable;
            }
        }

        return new ExtensionInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            propertyName,
            isNullable);
    }

    private static string GenerateWorldExtensions(ImmutableArray<ExtensionInfo> extensions)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace KeenEyes;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated extension members providing typed access to plugin extensions on World.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine("/// These extension members are generated from classes marked with <see cref=\"PluginExtensionAttribute\"/>.");
        sb.AppendLine("/// They provide convenient typed property access instead of using <see cref=\"World.GetExtension{T}\"/>.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("public static class WorldPluginExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    extension(global::KeenEyes.World world)");
        sb.AppendLine("    {");

        foreach (var ext in extensions)
        {
            var fullTypeName = ext.Namespace == "<global namespace>"
                ? ext.Name
                : $"global::{ext.FullName}";

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Gets the <see cref=\"{ext.FullName}\"/> extension from this world.");
            sb.AppendLine($"        /// </summary>");

            if (ext.IsNullable)
            {
                sb.AppendLine($"        /// <returns>The extension instance if registered; otherwise, null.</returns>");
                sb.AppendLine($"        public {fullTypeName}? {ext.PropertyName} => world.TryGetExtension<{fullTypeName}>(out var ext) ? ext : null;");
            }
            else
            {
                sb.AppendLine($"        /// <exception cref=\"global::System.InvalidOperationException\">Thrown when the extension is not registered.</exception>");
                sb.AppendLine($"        public {fullTypeName} {ext.PropertyName} => world.GetExtension<{fullTypeName}>();");
            }

            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed record ExtensionInfo(
        string Name,
        string Namespace,
        string FullName,
        string PropertyName,
        bool IsNullable);
}
