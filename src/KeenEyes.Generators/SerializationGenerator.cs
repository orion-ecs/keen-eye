using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates AOT-compatible serialization code for components marked with [Component(Serializable = true)].
/// Eliminates runtime reflection by generating strongly-typed serialization methods.
/// </summary>
[Generator]
public sealed class SerializationGenerator : IIncrementalGenerator
{
    private const string ComponentAttribute = "KeenEyes.ComponentAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all structs with [Component(Serializable = true)]
        var serializableComponents = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ComponentAttribute,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GetSerializableComponentInfo(ctx))
            .Where(static info => info is not null);

        var collected = serializableComponents.Collect();

        // Generate the serialization registry only if there are serializable components
        context.RegisterSourceOutput(collected, static (ctx, components) =>
        {
            var validComponents = components.Where(c => c is not null).ToImmutableArray();

            // Don't generate anything if there are no serializable components
            // This avoids conflicts when multiple projects reference KeenEyes.Core
            if (validComponents.Length == 0)
            {
                return;
            }

            var source = GenerateSerializationRegistry(validComponents!);
            ctx.AddSource("ComponentSerializer.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static SerializableComponentInfo? GetSerializableComponentInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        // Check for Serializable = true in attribute
        var attr = context.Attributes.FirstOrDefault();
        if (attr is null)
        {
            return null;
        }

        var serializableArg = attr.NamedArguments
            .FirstOrDefault(a => a.Key == "Serializable");

        if (serializableArg.Value.Value is not true)
        {
            return null;
        }

        // Collect fields for serialization
        var fields = new List<SerializableFieldInfo>();
        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IFieldSymbol field)
            {
                continue;
            }

            if (field.IsStatic || field.IsConst)
            {
                continue;
            }

            fields.Add(new SerializableFieldInfo(
                field.Name,
                field.Type.ToDisplayString(),
                GetJsonTypeName(field.Type)));
        }

        return new SerializableComponentInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            fields.ToImmutableArray());
    }

    private static string GetJsonTypeName(ITypeSymbol type)
    {
        // Map CLR types to JSON reader method names
        var displayString = type.ToDisplayString();
        return displayString switch
        {
            "int" or "System.Int32" => "Int32",
            "long" or "System.Int64" => "Int64",
            "short" or "System.Int16" => "Int16",
            "byte" or "System.Byte" => "Byte",
            "uint" or "System.UInt32" => "UInt32",
            "ulong" or "System.UInt64" => "UInt64",
            "ushort" or "System.UInt16" => "UInt16",
            "sbyte" or "System.SByte" => "SByte",
            "float" or "System.Single" => "Single",
            "double" or "System.Double" => "Double",
            "decimal" or "System.Decimal" => "Decimal",
            "bool" or "System.Boolean" => "Boolean",
            "string" or "System.String" => "String",
            _ => "Object" // For complex types, use generic deserialization
        };
    }

    private static string GenerateSerializationRegistry(ImmutableArray<SerializableComponentInfo?> components)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using KeenEyes.Serialization;");
        sb.AppendLine();
        sb.AppendLine("namespace KeenEyes.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated registry for AOT-compatible component serialization.");
        sb.AppendLine("/// Contains serialization methods for components marked with [Component(Serializable = true)].");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public sealed class ComponentSerializer : IComponentSerializer");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Shared instance for convenience.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static readonly ComponentSerializer Instance = new();");
        sb.AppendLine();
        sb.AppendLine("    private static readonly Dictionary<string, Func<JsonElement, object>> Deserializers;");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<object, JsonElement>> Serializers;");
        sb.AppendLine("    private static readonly Dictionary<string, Type> TypesByName;");
        sb.AppendLine("    private static readonly HashSet<Type> SerializableTypes;");
        sb.AppendLine();

        // Static constructor to initialize dictionaries
        sb.AppendLine("    static ComponentSerializer()");
        sb.AppendLine("    {");
        sb.AppendLine("        Deserializers = new Dictionary<string, Func<JsonElement, object>>");
        sb.AppendLine("        {");

        foreach (var component in components)
        {
            if (component is null)
            {
                continue;
            }

            sb.AppendLine($"            [typeof({component.FullName}).AssemblyQualifiedName!] = Deserialize_{component.Name},");
            sb.AppendLine($"            [\"{component.FullName}\"] = Deserialize_{component.Name},");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        Serializers = new Dictionary<Type, Func<object, JsonElement>>");
        sb.AppendLine("        {");

        foreach (var component in components)
        {
            if (component is null)
            {
                continue;
            }

            sb.AppendLine($"            [typeof({component.FullName})] = value => Serialize_{component.Name}(({component.FullName})value),");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        TypesByName = new Dictionary<string, Type>");
        sb.AppendLine("        {");

        foreach (var component in components)
        {
            if (component is null)
            {
                continue;
            }

            sb.AppendLine($"            [typeof({component.FullName}).AssemblyQualifiedName!] = typeof({component.FullName}),");
            sb.AppendLine($"            [\"{component.FullName}\"] = typeof({component.FullName}),");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        SerializableTypes = new HashSet<Type>");
        sb.AppendLine("        {");

        foreach (var component in components)
        {
            if (component is null)
            {
                continue;
            }

            sb.AppendLine($"            typeof({component.FullName}),");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Public API methods implementing IComponentSerializer
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public bool IsSerializable(Type type) => SerializableTypes.Contains(type);");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public bool IsSerializable(string typeName) => Deserializers.ContainsKey(typeName);");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public object? Deserialize(string typeName, JsonElement json)");
        sb.AppendLine("    {");
        sb.AppendLine("        return Deserializers.TryGetValue(typeName, out var deserializer)");
        sb.AppendLine("            ? deserializer(json)");
        sb.AppendLine("            : null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public JsonElement? Serialize(Type type, object value)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!Serializers.TryGetValue(type, out var serializer))");
        sb.AppendLine("        {");
        sb.AppendLine("            return null;");
        sb.AppendLine("        }");
        sb.AppendLine("        return serializer(value);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    Type? IComponentSerializer.GetType(string typeName)");
        sb.AppendLine("    {");
        sb.AppendLine("        return TypesByName.TryGetValue(typeName, out var type) ? type : null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets all registered serializable type names.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public IEnumerable<string> GetSerializableTypeNames() => Deserializers.Keys;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets all registered serializable types.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public IEnumerable<Type> GetSerializableTypes() => SerializableTypes;");
        sb.AppendLine();

        // Generate individual serialization/deserialization methods
        foreach (var component in components)
        {
            if (component is null)
            {
                continue;
            }

            GenerateComponentMethods(sb, component);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateComponentMethods(StringBuilder sb, SerializableComponentInfo component)
    {
        var camelCaseName = ToCamelCase(component.Name);

        // Deserialize method
        sb.AppendLine($"    private static object Deserialize_{component.Name}(JsonElement json)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var result = new {component.FullName}();");

        foreach (var field in component.Fields)
        {
            var camelFieldName = ToCamelCase(field.Name);
            sb.AppendLine($"        if (json.TryGetProperty(\"{camelFieldName}\", out var {camelFieldName}Elem))");
            sb.AppendLine("        {");

            if (field.JsonTypeName == "Object")
            {
                // Complex type - use generic deserialization
                sb.AppendLine($"            result.{field.Name} = JsonSerializer.Deserialize<{field.Type}>({camelFieldName}Elem.GetRawText())!;");
            }
            else if (field.JsonTypeName == "String")
            {
                sb.AppendLine($"            result.{field.Name} = {camelFieldName}Elem.GetString()!;");
            }
            else
            {
                sb.AppendLine($"            result.{field.Name} = {camelFieldName}Elem.Get{field.JsonTypeName}();");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Serialize method
        sb.AppendLine($"    private static JsonElement Serialize_{component.Name}({component.FullName} value)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var stream = new System.IO.MemoryStream();");
        sb.AppendLine("        using var writer = new Utf8JsonWriter(stream);");
        sb.AppendLine("        writer.WriteStartObject();");

        foreach (var field in component.Fields)
        {
            var camelFieldName = ToCamelCase(field.Name);

            if (field.JsonTypeName == "Object")
            {
                sb.AppendLine($"        writer.WritePropertyName(\"{camelFieldName}\");");
                sb.AppendLine($"        JsonSerializer.Serialize(writer, value.{field.Name});");
            }
            else if (field.JsonTypeName == "String")
            {
                sb.AppendLine($"        writer.WriteString(\"{camelFieldName}\", value.{field.Name});");
            }
            else if (field.JsonTypeName == "Boolean")
            {
                sb.AppendLine($"        writer.WriteBoolean(\"{camelFieldName}\", value.{field.Name});");
            }
            else
            {
                sb.AppendLine($"        writer.WriteNumber(\"{camelFieldName}\", value.{field.Name});");
            }
        }

        sb.AppendLine("        writer.WriteEndObject();");
        sb.AppendLine("        writer.Flush();");
        sb.AppendLine("        stream.Position = 0;");
        sb.AppendLine("        return JsonDocument.Parse(stream).RootElement.Clone();");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }

        if (name.Length == 1)
        {
            return name.ToLowerInvariant();
        }

        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private sealed record SerializableComponentInfo(
        string Name,
        string Namespace,
        string FullName,
        ImmutableArray<SerializableFieldInfo> Fields);

    private sealed record SerializableFieldInfo(
        string Name,
        string Type,
        string JsonTypeName);
}
