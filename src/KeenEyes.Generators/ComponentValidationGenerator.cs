using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates compile-time validation metadata for components marked with
/// [RequiresComponent] or [ConflictsWith] attributes.
/// </summary>
[Generator]
public sealed class ComponentValidationGenerator : IIncrementalGenerator
{
    private const string ComponentAttribute = "KeenEyes.ComponentAttribute";
    private const string TagComponentAttribute = "KeenEyes.TagComponentAttribute";
    private const string RequiresComponentAttribute = "KeenEyes.RequiresComponentAttribute";
    private const string ConflictsWithAttribute = "KeenEyes.ConflictsWithAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all structs with [Component] attribute that also have validation attributes
        var componentProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ComponentAttribute,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GetValidationInfo(ctx))
            .Where(static info => info is not null && info.HasConstraints);

        // Find all structs with [TagComponent] attribute that also have validation attributes
        var tagComponentProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                TagComponentAttribute,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GetValidationInfo(ctx))
            .Where(static info => info is not null && info.HasConstraints);

        // Combine both providers
        var allComponents = componentProvider.Collect()
            .Combine(tagComponentProvider.Collect());

        // Generate the code
        context.RegisterSourceOutput(allComponents, static (ctx, source) =>
        {
            var (components, tagComponents) = source;
            var allInfos = components.Concat(tagComponents)
                .Where(i => i is not null)
                .Cast<ValidationInfo>()
                .ToImmutableArray();

            if (allInfos.Length == 0)
            {
                return;
            }

            // Generate validation metadata class
            var metadataSource = GenerateValidationMetadata(allInfos);
            ctx.AddSource("ComponentValidation.Metadata.g.cs", SourceText.From(metadataSource, Encoding.UTF8));
        });
    }

    private static ValidationInfo? GetValidationInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var requires = new List<string>();
        var conflicts = new List<string>();

        foreach (var attribute in typeSymbol.GetAttributes())
        {
            var attrClass = attribute.AttributeClass?.ToDisplayString();

            if (attrClass == RequiresComponentAttribute)
            {
                if (attribute.ConstructorArguments.Length > 0 &&
                    attribute.ConstructorArguments[0].Value is INamedTypeSymbol requiredType)
                {
                    requires.Add(requiredType.ToDisplayString());
                }
            }
            else if (attrClass == ConflictsWithAttribute)
            {
                if (attribute.ConstructorArguments.Length > 0 &&
                    attribute.ConstructorArguments[0].Value is INamedTypeSymbol conflictType)
                {
                    conflicts.Add(conflictType.ToDisplayString());
                }
            }
        }

        return new ValidationInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            [.. requires],
            [.. conflicts]);
    }

    private static string GenerateValidationMetadata(ImmutableArray<ValidationInfo> components)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace KeenEyes;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated compile-time validation metadata for components.");
        sb.AppendLine("/// This class provides validation constraints without runtime reflection.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static partial class ComponentValidationMetadata");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly Dictionary<Type, (Type[] Required, Type[] Conflicts)> Constraints = new()");
        sb.AppendLine("    {");

        foreach (var info in components)
        {
            var requiredTypes = info.RequiredComponents.Length > 0
                ? $"new Type[] {{ {string.Join(", ", info.RequiredComponents.Select(t => $"typeof({t})"))} }}"
                : "Array.Empty<Type>()";

            var conflictTypes = info.ConflictingComponents.Length > 0
                ? $"new Type[] {{ {string.Join(", ", info.ConflictingComponents.Select(t => $"typeof({t})"))} }}"
                : "Array.Empty<Type>()";

            sb.AppendLine($"        [typeof({info.FullName})] = ({requiredTypes}, {conflictTypes}),");
        }

        sb.AppendLine("    };");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the validation constraints for a component type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"componentType\">The component type to look up.</param>");
        sb.AppendLine("    /// <param name=\"required\">Output array of required component types.</param>");
        sb.AppendLine("    /// <param name=\"conflicts\">Output array of conflicting component types.</param>");
        sb.AppendLine("    /// <returns><c>true</c> if the component has validation constraints; <c>false</c> otherwise.</returns>");
        sb.AppendLine("    public static bool TryGetConstraints(Type componentType, out Type[] required, out Type[] conflicts)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (Constraints.TryGetValue(componentType, out var constraints))");
        sb.AppendLine("        {");
        sb.AppendLine("            required = constraints.Required;");
        sb.AppendLine("            conflicts = constraints.Conflicts;");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        required = Array.Empty<Type>();");
        sb.AppendLine("        conflicts = Array.Empty<Type>();");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Checks if a component type has any validation constraints.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"componentType\">The component type to check.</param>");
        sb.AppendLine("    /// <returns><c>true</c> if the component has constraints; <c>false</c> otherwise.</returns>");
        sb.AppendLine("    public static bool HasConstraints(Type componentType)");
        sb.AppendLine("    {");
        sb.AppendLine("        return Constraints.ContainsKey(componentType);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate typed accessor methods for each component
        foreach (var info in components)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Gets the validation constraints for <see cref=\"{info.FullName}\"/>.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static (Type[] Required, Type[] Conflicts) Get{info.Name}Constraints()");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        return Constraints[typeof({info.FullName})];");
            sb.AppendLine($"    }}");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed record ValidationInfo(
        string Name,
        string Namespace,
        string FullName,
        ImmutableArray<string> RequiredComponents,
        ImmutableArray<string> ConflictingComponents)
    {
        public bool HasConstraints => RequiredComponents.Length > 0 || ConflictingComponents.Length > 0;
    }
}
