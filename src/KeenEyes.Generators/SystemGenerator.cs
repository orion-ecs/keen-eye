using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates system metadata and extension methods for types marked with [System].
/// Provides discovery information and convenient AddXxxSystem extension methods.
/// </summary>
[Generator]
public sealed class SystemGenerator : IIncrementalGenerator
{
    private const string SystemAttribute = "KeenEyes.SystemAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var systemProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                SystemAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetSystemInfo(ctx))
            .Where(static info => info is not null);

        // Generate individual system partials
        context.RegisterSourceOutput(systemProvider, static (ctx, info) =>
        {
            if (info is null)
            {
                return;
            }

            var source = GenerateSystemPartial(info);
            ctx.AddSource($"{info.FullName}.System.g.cs", SourceText.From(source, Encoding.UTF8));

            // Generate extension methods
            var extensions = GenerateExtensionMethods(info);
            ctx.AddSource($"{info.FullName}.Extensions.g.cs", SourceText.From(extensions, Encoding.UTF8));
        });
    }

    private static SystemInfo? GetSystemInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var attr = context.Attributes.FirstOrDefault();
        if (attr is null)
        {
            return null;
        }

        // Extract attribute properties
        var phase = SystemPhase.Update;
        var order = 0;
        string? group = null;

        foreach (var namedArg in attr.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "Phase":
                    phase = (SystemPhase)(int)namedArg.Value.Value!;
                    break;
                case "Order":
                    order = (int)namedArg.Value.Value!;
                    break;
                case "Group":
                    group = namedArg.Value.Value as string;
                    break;
            }
        }

        return new SystemInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            phase,
            order,
            group);
    }

    private static string GenerateSystemPartial(SystemInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var groupStr = info.Group is not null ? $"\"{info.Group}\"" : "null";

        // Generate partial with metadata properties
        sb.AppendLine($"partial class {info.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>The execution phase for this system.</summary>");
        sb.AppendLine($"    public static global::KeenEyes.SystemPhase Phase => global::KeenEyes.SystemPhase.{info.Phase};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The execution order within the phase.</summary>");
        sb.AppendLine($"    public static int Order => {info.Order};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The system group name, if any.</summary>");
        sb.AppendLine($"    public static string? Group => {groupStr};");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateExtensionMethods(SystemInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Use the same namespace as the system for discoverability
        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var fullTypeName = info.Namespace is "<global namespace>" or ""
            ? $"global::{info.Name}"
            : $"global::{info.Namespace}.{info.Name}";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Extension methods for adding <see cref=\"{info.Name}\"/> to worlds and groups.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public static class {info.Name}Extensions");
        sb.AppendLine("{");

        // World extension method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Adds a <see cref=\"{info.Name}\"/> to the world with its configured phase and order.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"world\">The world to add the system to.</param>");
        sb.AppendLine($"    /// <returns>The world for method chaining.</returns>");
        sb.AppendLine($"    /// <remarks>");
        sb.AppendLine($"    /// <para>Phase: <see cref=\"global::KeenEyes.SystemPhase.{info.Phase}\"/></para>");
        sb.AppendLine($"    /// <para>Order: {info.Order}</para>");
        if (info.Group is not null)
        {
            sb.AppendLine($"    /// <para>Group: {info.Group}</para>");
        }
        sb.AppendLine($"    /// </remarks>");
        sb.AppendLine($"    public static global::KeenEyes.World Add{info.Name}(this global::KeenEyes.World world)");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        return world.AddSystem<{fullTypeName}>(global::KeenEyes.SystemPhase.{info.Phase}, order: {info.Order});");
        sb.AppendLine($"    }}");
        sb.AppendLine();

        // SystemGroup extension method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Adds a <see cref=\"{info.Name}\"/> to the system group with its configured order.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"group\">The system group to add the system to.</param>");
        sb.AppendLine($"    /// <returns>The system group for method chaining.</returns>");
        sb.AppendLine($"    /// <remarks>");
        sb.AppendLine($"    /// <para>Order: {info.Order}</para>");
        sb.AppendLine($"    /// </remarks>");
        sb.AppendLine($"    public static global::KeenEyes.SystemGroup Add{info.Name}(this global::KeenEyes.SystemGroup group)");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        return group.Add<{fullTypeName}>(order: {info.Order});");
        sb.AppendLine($"    }}");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private enum SystemPhase
    {
        EarlyUpdate,
        FixedUpdate,
        Update,
        LateUpdate,
        Render,
        PostRender
    }

    private sealed record SystemInfo(
        string Name,
        string Namespace,
        string FullName,
        SystemPhase Phase,
        int Order,
        string? Group);
}
