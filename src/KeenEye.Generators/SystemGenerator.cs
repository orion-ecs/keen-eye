using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEye.Generators;

/// <summary>
/// Generates system metadata for types marked with [System].
/// Only provides discovery information - registration is left to the user.
/// </summary>
[Generator]
public sealed class SystemGenerator : IIncrementalGenerator
{
    private const string SystemAttribute = "KeenEye.SystemAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var systemProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                SystemAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetSystemInfo(ctx))
            .Where(static info => info is not null);

        // Generate individual system partials
        context.RegisterSourceOutput(systemProvider, static (ctx, info) =>
        {
            if (info is null)
            {
                return;
            }

            var source = GenerateSystemPartial(info);
            ctx.AddSource($"{info.FullName}.System.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static SystemInfo? GetSystemInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var attr = context.Attributes.FirstOrDefault();
        if (attr is null)
        {
            return null;
        }

        // Extract attribute properties
        var phase = SystemPhase.Update;
        var order = 0;
        string? group = null;

        foreach (var namedArg in attr.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "Phase":
                    phase = (SystemPhase)(int)namedArg.Value.Value!;
                    break;
                case "Order":
                    order = (int)namedArg.Value.Value!;
                    break;
                case "Group":
                    group = namedArg.Value.Value as string;
                    break;
            }
        }

        return new SystemInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            phase,
            order,
            group);
    }

    private static string GenerateSystemPartial(SystemInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var groupStr = info.Group is not null ? $"\"{info.Group}\"" : "null";

        // Generate partial with metadata properties
        sb.AppendLine($"partial class {info.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>The execution phase for this system.</summary>");
        sb.AppendLine($"    public static global::KeenEye.SystemPhase Phase => global::KeenEye.SystemPhase.{info.Phase};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The execution order within the phase.</summary>");
        sb.AppendLine($"    public static int Order => {info.Order};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The system group name, if any.</summary>");
        sb.AppendLine($"    public static string? Group => {groupStr};");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private enum SystemPhase
    {
        EarlyUpdate,
        FixedUpdate,
        Update,
        LateUpdate,
        Render,
        PostRender
    }

    private sealed record SystemInfo(
        string Name,
        string Namespace,
        string FullName,
        SystemPhase Phase,
        int Order,
        string? Group);
}
