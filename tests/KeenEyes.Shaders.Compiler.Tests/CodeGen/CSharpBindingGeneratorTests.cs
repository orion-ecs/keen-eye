using KeenEyes.Shaders.Compiler;
using KeenEyes.Shaders.Compiler.CodeGen;
using KeenEyes.Shaders.Compiler.Parsing.Ast;

namespace KeenEyes.Shaders.Compiler.Tests.CodeGen;

/// <summary>
/// Tests for the CSharpBindingGenerator class.
/// </summary>
public class CSharpBindingGeneratorTests
{
    #region Vertex Shader - Basic Structure

    [Fact]
    public void GenerateVertexShader_ContainsAutoGeneratedHeader()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("// <auto-generated>", csharp);
        Assert.Contains("// This code was generated by the KESL compiler.", csharp);
    }

    [Fact]
    public void GenerateVertexShader_ContainsNamespace()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("namespace Generated;", csharp);
    }

    [Fact]
    public void GenerateVertexShader_ImplementsIGpuVertexShader()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public sealed partial class SimpleVertexShader : IGpuVertexShader", csharp);
    }

    [Fact]
    public void GenerateVertexShader_ContainsNameProperty()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public string Name => \"SimpleVertex\";", csharp);
    }

    #endregion

    #region Vertex Shader - Input Layout

    [Fact]
    public void GenerateVertexShader_ContainsInputLayoutProperty()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public InputLayoutDescriptor InputLayout { get; }", csharp);
    }

    [Fact]
    public void GenerateVertexShader_InputLayoutContainsAttributes()
    {
        var csharp = GenerateVertexCSharp(VertexShaderWithMultipleInputs);

        Assert.Contains("new InputAttribute(\"position\", AttributeType.Float3, 0)", csharp);
        Assert.Contains("new InputAttribute(\"normal\", AttributeType.Float3, 1)", csharp);
        Assert.Contains("new InputAttribute(\"texCoord\", AttributeType.Float2, 2)", csharp);
    }

    #endregion

    #region Vertex Shader - Outputs

    [Fact]
    public void GenerateVertexShader_ContainsOutputsProperty()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public IReadOnlyList<InputAttribute> Outputs { get; }", csharp);
    }

    [Fact]
    public void GenerateVertexShader_OutputsContainsAttributes()
    {
        var csharp = GenerateVertexCSharp(VertexShaderWithMultipleOutputs);

        Assert.Contains("new InputAttribute(\"worldPos\", AttributeType.Float3,", csharp);
        Assert.Contains("new InputAttribute(\"worldNormal\", AttributeType.Float3,", csharp);
        Assert.Contains("new InputAttribute(\"uv\", AttributeType.Float2,", csharp);
    }

    #endregion

    #region Vertex Shader - Uniforms

    [Fact]
    public void GenerateVertexShader_ContainsUniformsProperty()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public IReadOnlyList<UniformDescriptor> Uniforms { get; }", csharp);
    }

    [Fact]
    public void GenerateVertexShader_UniformsContainsParams()
    {
        var csharp = GenerateVertexCSharp(VertexShaderWithParams);

        Assert.Contains("new UniformDescriptor(\"model\", UniformType.Matrix4)", csharp);
        Assert.Contains("new UniformDescriptor(\"view\", UniformType.Matrix4)", csharp);
        Assert.Contains("new UniformDescriptor(\"projection\", UniformType.Matrix4)", csharp);
    }

    [Fact]
    public void GenerateVertexShader_NoParams_EmptyUniforms()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public IReadOnlyList<UniformDescriptor> Uniforms { get; } = [];", csharp);
    }

    #endregion

    #region Vertex Shader - GetShaderSource

    [Fact]
    public void GenerateVertexShader_ContainsGetShaderSourceMethod()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("public string GetShaderSource(ShaderBackend backend)", csharp);
    }

    [Fact]
    public void GenerateVertexShader_GetShaderSourceHandlesBackends()
    {
        var csharp = GenerateVertexCSharp(SimpleVertexShader);

        Assert.Contains("ShaderBackend.GLSL =>", csharp);
        Assert.Contains("ShaderBackend.HLSL =>", csharp);
    }

    #endregion

    #region Fragment Shader - Basic Structure

    [Fact]
    public void GenerateFragmentShader_ContainsAutoGeneratedHeader()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("// <auto-generated>", csharp);
    }

    [Fact]
    public void GenerateFragmentShader_ImplementsIGpuFragmentShader()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("public sealed partial class SimpleFragmentShader : IGpuFragmentShader", csharp);
    }

    [Fact]
    public void GenerateFragmentShader_ContainsNameProperty()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("public string Name => \"SimpleFragment\";", csharp);
    }

    #endregion

    #region Fragment Shader - Inputs

    [Fact]
    public void GenerateFragmentShader_ContainsInputsProperty()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("public IReadOnlyList<InputAttribute> Inputs { get; }", csharp);
    }

    [Fact]
    public void GenerateFragmentShader_InputsContainsAttributes()
    {
        var csharp = GenerateFragmentCSharp(FragmentShaderWithMultipleInputs);

        Assert.Contains("new InputAttribute(\"worldPos\", AttributeType.Float3,", csharp);
        Assert.Contains("new InputAttribute(\"worldNormal\", AttributeType.Float3,", csharp);
        Assert.Contains("new InputAttribute(\"uv\", AttributeType.Float2,", csharp);
    }

    #endregion

    #region Fragment Shader - Outputs

    [Fact]
    public void GenerateFragmentShader_ContainsOutputsProperty()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("public IReadOnlyList<OutputTarget> Outputs { get; }", csharp);
    }

    [Fact]
    public void GenerateFragmentShader_OutputsContainsTargets()
    {
        var csharp = GenerateFragmentCSharp(FragmentShaderWithMultipleOutputs);

        Assert.Contains("new OutputTarget(\"fragColor\", AttributeType.Float4, 0)", csharp);
        Assert.Contains("new OutputTarget(\"brightColor\", AttributeType.Float4, 1)", csharp);
    }

    #endregion

    #region Fragment Shader - Uniforms

    [Fact]
    public void GenerateFragmentShader_UniformsContainsParams()
    {
        var csharp = GenerateFragmentCSharp(FragmentShaderWithParams);

        Assert.Contains("new UniformDescriptor(\"lightDir\", UniformType.Float3)", csharp);
        Assert.Contains("new UniformDescriptor(\"lightColor\", UniformType.Float3)", csharp);
    }

    #endregion

    #region Fragment Shader - GetShaderSource

    [Fact]
    public void GenerateFragmentShader_ContainsGetShaderSourceMethod()
    {
        var csharp = GenerateFragmentCSharp(SimpleFragmentShader);

        Assert.Contains("public string GetShaderSource(ShaderBackend backend)", csharp);
    }

    #endregion

    #region Custom Namespace

    [Fact]
    public void GenerateVertexShader_WithCustomNamespace_UsesNamespace()
    {
        var csharp = GenerateVertexCSharpWithNamespace(SimpleVertexShader, "MyGame.Shaders");

        Assert.Contains("namespace MyGame.Shaders;", csharp);
    }

    [Fact]
    public void GenerateFragmentShader_WithCustomNamespace_UsesNamespace()
    {
        var csharp = GenerateFragmentCSharpWithNamespace(SimpleFragmentShader, "MyGame.Shaders");

        Assert.Contains("namespace MyGame.Shaders;", csharp);
    }

    #endregion

    #region Test Shader Sources

    private const string SimpleVertexShader = @"
        vertex SimpleVertex {
            in {
                position: float3 @ 0
            }
            out {
                outPos: float3
            }
            execute() {
                outPos = position;
            }
        }
    ";

    private const string VertexShaderWithMultipleInputs = @"
        vertex TransformVertex {
            in {
                position: float3 @ 0
                normal: float3 @ 1
                texCoord: float2 @ 2
            }
            out {
                worldPos: float3
            }
            execute() {
                worldPos = position;
            }
        }
    ";

    private const string VertexShaderWithMultipleOutputs = @"
        vertex MultiOutputVertex {
            in {
                position: float3 @ 0
                normal: float3 @ 1
                texCoord: float2 @ 2
            }
            out {
                worldPos: float3
                worldNormal: float3
                uv: float2
            }
            execute() {
                worldPos = position;
                worldNormal = normal;
                uv = texCoord;
            }
        }
    ";

    private const string VertexShaderWithParams = @"
        vertex ParamVertex {
            in {
                position: float3 @ 0
            }
            out {
                outPos: float3
            }
            params {
                model: mat4
                view: mat4
                projection: mat4
            }
            execute() {
                outPos = position;
            }
        }
    ";

    private const string SimpleFragmentShader = @"
        fragment SimpleFragment {
            in {
                color: float4
            }
            out {
                fragColor: float4 @ 0
            }
            execute() {
                fragColor = color;
            }
        }
    ";

    private const string FragmentShaderWithMultipleInputs = @"
        fragment MultiInputFragment {
            in {
                worldPos: float3
                worldNormal: float3
                uv: float2
            }
            out {
                fragColor: float4 @ 0
            }
            execute() {
                fragColor = worldNormal;
            }
        }
    ";

    private const string FragmentShaderWithParams = @"
        fragment ParamFragment {
            in {
                worldNormal: float3
            }
            out {
                fragColor: float4 @ 0
            }
            params {
                lightDir: float3
                lightColor: float3
            }
            execute() {
                fragColor = lightColor;
            }
        }
    ";

    private const string FragmentShaderWithMultipleOutputs = @"
        fragment MultiOutputFragment {
            in {
                color: float4
            }
            out {
                fragColor: float4 @ 0
                brightColor: float4 @ 1
            }
            execute() {
                fragColor = color;
                brightColor = color;
            }
        }
    ";

    #endregion

    #region Helper Methods

    private static string GenerateVertexCSharp(string source)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var vertex = result.SourceFile!.Declarations.OfType<VertexDeclaration>().First();
        var compiler = new KeslCompiler();
        return compiler.GenerateCSharp(vertex);
    }

    private static string GenerateFragmentCSharp(string source)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var fragment = result.SourceFile!.Declarations.OfType<FragmentDeclaration>().First();
        var compiler = new KeslCompiler();
        return compiler.GenerateCSharp(fragment);
    }

    private static string GenerateVertexCSharpWithNamespace(string source, string ns)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var vertex = result.SourceFile!.Declarations.OfType<VertexDeclaration>().First();
        var compiler = new KeslCompiler { Namespace = ns };
        return compiler.GenerateCSharp(vertex);
    }

    private static string GenerateFragmentCSharpWithNamespace(string source, string ns)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var fragment = result.SourceFile!.Declarations.OfType<FragmentDeclaration>().First();
        var compiler = new KeslCompiler { Namespace = ns };
        return compiler.GenerateCSharp(fragment);
    }

    private static string GeneratePipelineCSharp(string source)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var pipeline = result.SourceFile!.Declarations.OfType<PipelineDeclaration>().First();
        var compiler = new KeslCompiler();
        return compiler.GenerateCSharp(pipeline);
    }

    private static string GeneratePipelineCSharpWithNamespace(string source, string ns)
    {
        var result = KeslCompiler.Compile(source);
        Assert.False(result.HasErrors, $"Compilation errors: {string.Join(", ", result.Diagnostics.Select(d => d.Message))}");

        var pipeline = result.SourceFile!.Declarations.OfType<PipelineDeclaration>().First();
        var compiler = new KeslCompiler { Namespace = ns };
        return compiler.GenerateCSharp(pipeline);
    }

    #endregion

    #region Pipeline Test Sources

    private const string SimplePipelineSource = @"
        pipeline SimplePipeline {
            vertex: BasicVertex
            fragment: BasicFragment
        }
    ";

    private const string PipelineWithGeometry = @"
        pipeline GeomPipeline {
            vertex: TransformVertex
            geometry: WireframeExpander
            fragment: WireSurface
        }
    ";

    private const string PipelineWithInlineVertex = @"
        vertex DefaultFragment {
            in { color: float4 @ 0 }
            out { outColor: float4 }
            execute() { outColor = color; }
        }
        pipeline InlinePipeline {
            vertex {
                in {
                    position: float3 @ 0
                }
                out {
                    worldPos: float3
                }
                execute() {
                    worldPos = position;
                }
            }
            fragment: DefaultFragment
        }
    ";

    #endregion

    #region Pipeline - Basic Structure

    [Fact]
    public void GeneratePipeline_ContainsAutoGeneratedHeader()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("// <auto-generated>", csharp);
        Assert.Contains("// This code was generated by the KESL compiler.", csharp);
    }

    [Fact]
    public void GeneratePipeline_ContainsNamespace()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("namespace Generated;", csharp);
    }

    [Fact]
    public void GeneratePipeline_ImplementsIShaderPipeline()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public sealed partial class SimplePipelinePipeline : IShaderPipeline", csharp);
    }

    [Fact]
    public void GeneratePipeline_ContainsNameProperty()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public string Name => \"SimplePipeline\";", csharp);
    }

    #endregion

    #region Pipeline - Stage References

    [Fact]
    public void GeneratePipeline_ContainsVertexShaderName()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public string? VertexShaderName => \"BasicVertex\";", csharp);
    }

    [Fact]
    public void GeneratePipeline_ContainsFragmentShaderName()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public string? FragmentShaderName => \"BasicFragment\";", csharp);
    }

    [Fact]
    public void GeneratePipeline_NoGeometry_GeometryShaderNameIsNull()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public string? GeometryShaderName => null;", csharp);
    }

    [Fact]
    public void GeneratePipeline_WithGeometry_ContainsGeometryShaderName()
    {
        var csharp = GeneratePipelineCSharp(PipelineWithGeometry);

        Assert.Contains("public string? GeometryShaderName => \"WireframeExpander\";", csharp);
    }

    #endregion

    #region Pipeline - Stage Flags

    [Fact]
    public void GeneratePipeline_ContainsHasVertexStage()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public bool HasVertexStage => true;", csharp);
    }

    [Fact]
    public void GeneratePipeline_ContainsHasFragmentStage()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public bool HasFragmentStage => true;", csharp);
    }

    [Fact]
    public void GeneratePipeline_NoGeometry_HasGeometryStageIsFalse()
    {
        var csharp = GeneratePipelineCSharp(SimplePipelineSource);

        Assert.Contains("public bool HasGeometryStage => false;", csharp);
    }

    [Fact]
    public void GeneratePipeline_WithGeometry_HasGeometryStageIsTrue()
    {
        var csharp = GeneratePipelineCSharp(PipelineWithGeometry);

        Assert.Contains("public bool HasGeometryStage => true;", csharp);
    }

    #endregion

    #region Pipeline - Inline Shaders

    [Fact]
    public void GeneratePipeline_WithInlineShader_GeneratesShaderName()
    {
        var csharp = GeneratePipelineCSharp(PipelineWithInlineVertex);

        Assert.Contains("public string? VertexShaderName => \"InlinePipeline_vertex\";", csharp);
    }

    #endregion

    #region Pipeline - Custom Namespace

    [Fact]
    public void GeneratePipeline_WithCustomNamespace_UsesNamespace()
    {
        var csharp = GeneratePipelineCSharpWithNamespace(SimplePipelineSource, "MyGame.Pipelines");

        Assert.Contains("namespace MyGame.Pipelines;", csharp);
    }

    #endregion
}
