using System;
using System.IO;
using System.Linq;
using System.Text;
using KeenEyes.Shaders.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Shaders.Generator;

/// <summary>
/// Incremental source generator that compiles KESL (.kesl) files and generates C# bindings.
/// </summary>
[Generator]
public sealed class KeslSourceGenerator : IIncrementalGenerator
{
    private const string KeslExtension = ".kesl";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all .kesl files marked as AdditionalFiles
        var keslFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(KeslExtension, StringComparison.OrdinalIgnoreCase));

        // Get the root namespace from compilation options
        var compilationAndFiles = context.CompilationProvider
            .Combine(keslFiles.Collect());

        // Generate C# for each .kesl file
        context.RegisterSourceOutput(compilationAndFiles, static (ctx, source) =>
        {
            var (compilation, files) = source;
            var rootNamespace = GetRootNamespace(compilation);

            foreach (var file in files)
            {
                GenerateFromKeslFile(ctx, file, rootNamespace);
            }
        });
    }

    private static string GetRootNamespace(Compilation compilation)
    {
        // RootNamespace isn't directly available in compilation options,
        // so we use the assembly name as the namespace
        return compilation.AssemblyName ?? "Generated";
    }

    private static void GenerateFromKeslFile(
        SourceProductionContext context,
        AdditionalText file,
        string rootNamespace)
    {
        var sourceText = file.GetText(context.CancellationToken);
        if (sourceText is null)
        {
            return;
        }

        var source = sourceText.ToString();
        var filePath = file.Path;
        var fileName = Path.GetFileNameWithoutExtension(filePath);

        var compiler = new KeslCompiler
        {
            Namespace = rootNamespace
        };

        var output = compiler.CompileAndGenerate(source, filePath);

        // Report any compilation errors as diagnostics
        foreach (var diagnostic in output.Diagnostics)
        {
            var location = Location.Create(
                filePath,
                TextSpan.FromBounds(0, 0),
                new LinePositionSpan(
                    new LinePosition(diagnostic.Span.Start.Line - 1, diagnostic.Span.Start.Column - 1),
                    new LinePosition(diagnostic.Span.Start.Line - 1, diagnostic.Span.Start.Column)));

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "KESL001",
                    title: "KESL Compilation Error",
                    messageFormat: "{0}",
                    category: "KeenEyes.Shaders",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                location,
                diagnostic.Message));
        }

        if (output.HasErrors)
        {
            return;
        }

        // Add generated C# source for each shader
        foreach (var shader in output.Shaders)
        {
            var hintName = $"{fileName}.{shader.ShaderName}.g.cs";
            context.AddSource(hintName, SourceText.From(shader.CSharpCode, Encoding.UTF8));

            // Also add the GLSL as an embedded resource comment in a separate file
            var glslHintName = $"{fileName}.{shader.ShaderName}.glsl.g.cs";
            var glslWrapper = GenerateGlslResourceClass(rootNamespace, shader.ShaderName, shader.GlslCode);
            context.AddSource(glslHintName, SourceText.From(glslWrapper, Encoding.UTF8));
        }
    }

    private static string GenerateGlslResourceClass(string ns, string shaderName, string glslCode)
    {
        var escapedGlsl = glslCode
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r", "")
            .Replace("\n", "\\n\" +\n            \"");

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Contains the GLSL source code for the {shaderName} compute shader.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static partial class {shaderName}GlslSource");
        sb.AppendLine("    {");
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// The GLSL compute shader source code.");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public const string Source = \"{escapedGlsl}\";");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
