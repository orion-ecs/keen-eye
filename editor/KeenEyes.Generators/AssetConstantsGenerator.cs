using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1035 // Roslyn analyzers warn about non-shipping analyzer target frameworks

namespace KeenEyes.Generators;

/// <summary>
/// Generates type-safe asset path constants from asset files, eliminating magic strings.
/// </summary>
/// <remarks>
/// <para>
/// This generator scans AdditionalFiles for known asset extensions and creates
/// nested static classes with const string paths. This enables compile-time
/// validation of asset references and IDE autocompletion.
/// </para>
/// <para>
/// Enable via MSBuild properties:
/// <code>
/// &lt;PropertyGroup&gt;
///   &lt;GenerateAssetConstants&gt;true&lt;/GenerateAssetConstants&gt;
///   &lt;AssetConstantsNamespace&gt;MyGame&lt;/AssetConstantsNamespace&gt;
///   &lt;AssetConstantsClassName&gt;Assets&lt;/AssetConstantsClassName&gt;
/// &lt;/PropertyGroup&gt;
/// </code>
/// </para>
/// </remarks>
[Generator]
public sealed class AssetConstantsGenerator : IIncrementalGenerator
{
    private static readonly HashSet<string> KnownAssetExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        // Textures
        ".png", ".jpg", ".jpeg", ".bmp", ".tga", ".gif", ".psd", ".hdr", ".webp", ".dds",
        // Audio
        ".wav", ".ogg", ".mp3", ".flac",
        // Fonts
        ".ttf", ".otf",
        // Data
        ".json", ".xml", ".yaml", ".yml",
        // Atlases and animations
        ".atlas", ".keanim",
        // Models
        ".glb", ".gltf",
        // Shaders (raw)
        ".glsl", ".vert", ".frag",
        // KeenEyes specific
        ".kescene", ".keprefab", ".keworld"
    };

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get the namespace and class name from analyzer config options
        var configProvider = context.AnalyzerConfigOptionsProvider
            .Select(static (options, _) =>
            {
                options.GlobalOptions.TryGetValue("build_property.GenerateAssetConstants", out var generateStr);
                options.GlobalOptions.TryGetValue("build_property.AssetConstantsNamespace", out var ns);
                options.GlobalOptions.TryGetValue("build_property.AssetConstantsClassName", out var className);
                options.GlobalOptions.TryGetValue("build_property.AssetConstantsRootPath", out var rootPath);

                var generate = string.Equals(generateStr, "true", StringComparison.OrdinalIgnoreCase);
                return new GeneratorConfig(
                    Generate: generate,
                    Namespace: string.IsNullOrWhiteSpace(ns) ? null : ns,
                    ClassName: string.IsNullOrWhiteSpace(className) ? "Assets" : className!,
                    RootPath: string.IsNullOrWhiteSpace(rootPath) ? null : rootPath);
            });

        // Collect all AdditionalFiles that match known asset extensions
        var assetFilesProvider = context.AdditionalTextsProvider
            .Where(static file => IsAssetFile(file.Path))
            .Select(static (file, _) => file.Path)
            .Collect();

        // Combine config with asset files
        var combined = configProvider.Combine(assetFilesProvider);

        // Generate the source
        context.RegisterSourceOutput(combined, static (ctx, tuple) =>
        {
            var (config, assetFiles) = tuple;

            // Skip if generation is disabled
            if (!config.Generate || assetFiles.IsEmpty)
            {
                return;
            }

            var source = GenerateAssetConstants(config, assetFiles);
            ctx.AddSource("Assets.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsAssetFile(string path)
    {
        var extension = System.IO.Path.GetExtension(path);
        return !string.IsNullOrEmpty(extension) && KnownAssetExtensions.Contains(extension);
    }

    private static string GenerateAssetConstants(GeneratorConfig config, ImmutableArray<string> assetFiles)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(config.Namespace))
        {
            sb.AppendLine($"namespace {config.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated asset path constants for compile-time validated asset references.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static partial class {config.ClassName}");
        sb.AppendLine("{");

        // Build a tree structure from asset paths
        var root = new AssetNode("Root", isDirectory: true);

        foreach (var filePath in assetFiles.OrderBy(p => p, StringComparer.OrdinalIgnoreCase))
        {
            var relativePath = GetRelativePath(filePath, config.RootPath);
            if (relativePath != null)
            {
                AddAssetToTree(root, relativePath, filePath);
            }
        }

        // Generate nested classes for each directory
        GenerateNestedClasses(sb, root, indent: 1, parentPath: "");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string? GetRelativePath(string fullPath, string? rootPath)
    {
        // Normalize path separators
        var normalizedPath = fullPath.Replace('\\', '/');

        if (!string.IsNullOrEmpty(rootPath))
        {
            var normalizedRoot = rootPath!.Replace('\\', '/');
            if (!normalizedRoot.EndsWith("/"))
            {
                normalizedRoot = normalizedRoot + "/";
            }

            var index = normalizedPath.IndexOf(normalizedRoot, StringComparison.OrdinalIgnoreCase);
            if (index >= 0)
            {
                return normalizedPath.Substring(index + normalizedRoot.Length);
            }
        }

        // Try to find common asset folder names
        var assetFolders = new[] { "/Assets/", "/assets/", "/Content/", "/content/", "/Resources/", "/resources/" };
        foreach (var folder in assetFolders)
        {
            var idx = normalizedPath.IndexOf(folder, StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                return normalizedPath.Substring(idx + 1); // Include the folder name
            }
        }

        // Fallback: use filename only
        return System.IO.Path.GetFileName(normalizedPath);
    }

    private static void AddAssetToTree(AssetNode root, string relativePath, string fullPath)
    {
        var parts = relativePath.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
        var current = root;

        // Navigate/create directory nodes
        for (var i = 0; i < parts.Length - 1; i++)
        {
            var dirName = parts[i];
            var sanitized = SanitizeIdentifier(dirName);

            if (!current.Children.TryGetValue(sanitized, out var child))
            {
                child = new AssetNode(dirName, isDirectory: true);
                current.Children[sanitized] = child;
            }

            current = child;
        }

        // Add the file node
        if (parts.Length > 0)
        {
            var fileName = parts[parts.Length - 1];
            var sanitized = SanitizeIdentifier(System.IO.Path.GetFileNameWithoutExtension(fileName));

            // Handle duplicate names by appending a number
            var baseName = sanitized;
            var counter = 1;
            while (current.Children.ContainsKey(sanitized))
            {
                sanitized = $"{baseName}_{counter++}";
            }

            current.Children[sanitized] = new AssetNode(fileName, isDirectory: false)
            {
                FullPath = fullPath,
                RelativePath = relativePath
            };
        }
    }

    private static void GenerateNestedClasses(StringBuilder sb, AssetNode node, int indent, string parentPath)
    {
        var indentStr = new string(' ', indent * 4);

        // Separate directories and files
        var directories = node.Children
            .Where(kvp => kvp.Value.IsDirectory)
            .OrderBy(kvp => kvp.Key, StringComparer.OrdinalIgnoreCase)
            .ToList();

        var files = node.Children
            .Where(kvp => !kvp.Value.IsDirectory)
            .OrderBy(kvp => kvp.Key, StringComparer.OrdinalIgnoreCase)
            .ToList();

        // Generate nested classes for directories
        foreach (var kvp in directories)
        {
            var name = kvp.Key;
            var child = kvp.Value;
            var childPath = string.IsNullOrEmpty(parentPath) ? child.OriginalName : $"{parentPath}/{child.OriginalName}";

            sb.AppendLine($"{indentStr}/// <summary>");
            sb.AppendLine($"{indentStr}/// Asset paths for the {child.OriginalName} directory.");
            sb.AppendLine($"{indentStr}/// </summary>");
            sb.AppendLine($"{indentStr}public static partial class {name}");
            sb.AppendLine($"{indentStr}{{");

            GenerateNestedClasses(sb, child, indent + 1, childPath);

            sb.AppendLine($"{indentStr}}}");
            sb.AppendLine();
        }

        // Generate constants for files
        foreach (var kvp in files)
        {
            var name = kvp.Key;
            var child = kvp.Value;
            if (child.RelativePath == null)
            {
                continue;
            }

            // Use forward slashes for consistency
            var assetPath = child.RelativePath.Replace('\\', '/');

            sb.AppendLine($"{indentStr}/// <summary>");
            sb.AppendLine($"{indentStr}/// Path to {child.OriginalName}.");
            sb.AppendLine($"{indentStr}/// </summary>");
            sb.AppendLine($"{indentStr}public const string {name} = \"{EscapeString(assetPath)}\";");
            sb.AppendLine();
        }
    }

    private static string SanitizeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return "_";
        }

        var sb = new StringBuilder(name.Length);

        // Handle leading digit
        if (char.IsDigit(name[0]))
        {
            sb.Append('_');
        }

        var capitalizeNext = true;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                if (capitalizeNext)
                {
                    sb.Append(char.ToUpperInvariant(c));
                    capitalizeNext = false;
                }
                else
                {
                    sb.Append(c);
                }
            }
            else if (c == '_')
            {
                // Keep underscores but capitalize next
                capitalizeNext = true;
            }
            else if (c == '-' || c == ' ' || c == '.')
            {
                // Convert separators to PascalCase
                capitalizeNext = true;
            }
            // Skip other characters
        }

        var result = sb.ToString();

        // Handle C# keywords
        if (IsCSharpKeyword(result))
        {
            result = "@" + result;
        }

        return string.IsNullOrEmpty(result) ? "_" : result;
    }

    private static bool IsCSharpKeyword(string name)
    {
        return name switch
        {
            "abstract" or "as" or "base" or "bool" or "break" or "byte" or "case" or
            "catch" or "char" or "checked" or "class" or "const" or "continue" or
            "decimal" or "default" or "delegate" or "do" or "double" or "else" or
            "enum" or "event" or "explicit" or "extern" or "false" or "finally" or
            "fixed" or "float" or "for" or "foreach" or "goto" or "if" or "implicit" or
            "in" or "int" or "interface" or "internal" or "is" or "lock" or "long" or
            "namespace" or "new" or "null" or "object" or "operator" or "out" or
            "override" or "params" or "private" or "protected" or "public" or "readonly" or
            "ref" or "return" or "sbyte" or "sealed" or "short" or "sizeof" or "stackalloc" or
            "static" or "string" or "struct" or "switch" or "this" or "throw" or "true" or
            "try" or "typeof" or "uint" or "ulong" or "unchecked" or "unsafe" or "ushort" or
            "using" or "virtual" or "void" or "volatile" or "while" => true,
            _ => false
        };
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"");
    }

    private sealed record GeneratorConfig(
        bool Generate,
        string? Namespace,
        string ClassName,
        string? RootPath);

    private sealed class AssetNode
    {
        public AssetNode(string originalName, bool isDirectory)
        {
            OriginalName = originalName;
            IsDirectory = isDirectory;
        }

        public string OriginalName { get; }
        public bool IsDirectory { get; }
        public string? FullPath { get; set; }
        public string? RelativePath { get; set; }
        public Dictionary<string, AssetNode> Children { get; } = new(StringComparer.OrdinalIgnoreCase);
    }
}
