using System.Collections.Generic;
using System.Linq;
using System.Text;
using KeenEyes.Generators.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace KeenEyes.Generators;

/// <summary>
/// Generates system metadata and extension methods for types marked with [System].
/// Provides discovery information and convenient AddXxxSystem extension methods.
/// </summary>
[Generator]
public sealed class SystemGenerator : IIncrementalGenerator
{
    private const string SystemAttribute = "KeenEyes.SystemAttribute";
    private const string RunBeforeAttribute = "KeenEyes.RunBeforeAttribute";
    private const string RunAfterAttribute = "KeenEyes.RunAfterAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var systemProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                SystemAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetSystemInfo(ctx))
            .Where(static info => info is not null);

        // Generate individual system partials
        context.RegisterSourceOutput(systemProvider, static (ctx, info) =>
        {
            if (info is null)
            {
                return;
            }

            var source = GenerateSystemPartial(info);
            ctx.AddSource($"{info.FullName}.System.g.cs", SourceText.From(source, Encoding.UTF8));

            // Generate extension methods
            var extensions = GenerateExtensionMethods(info);
            ctx.AddSource($"{info.FullName}.Extensions.g.cs", SourceText.From(extensions, Encoding.UTF8));
        });
    }

    private static SystemInfo? GetSystemInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var attr = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == SystemAttribute);
        if (attr is null)
        {
            return null;
        }

        // Extract attribute properties
        var phase = SystemPhase.Update;
        var order = 0;
        string? group = null;

        foreach (var namedArg in attr.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "Phase" when namedArg.Value.Value is int phaseValue:
                    phase = (SystemPhase)phaseValue;
                    break;
                case "Order" when namedArg.Value.Value is int orderValue:
                    order = orderValue;
                    break;
                case "Group":
                    group = namedArg.Value.Value as string;
                    break;
            }
        }

        // Extract RunBefore and RunAfter attributes
        var runsBefore = new List<string>();
        var runsAfter = new List<string>();

        foreach (var attrData in typeSymbol.GetAttributes())
        {
            var attrName = attrData.AttributeClass?.ToDisplayString();
            if (attrName == RunBeforeAttribute && attrData.ConstructorArguments.Length > 0)
            {
                if (attrData.ConstructorArguments[0].Value is INamedTypeSymbol targetType)
                {
                    runsBefore.Add(targetType.ToDisplayString());
                }
            }
            else if (attrName == RunAfterAttribute && attrData.ConstructorArguments.Length > 0)
            {
                if (attrData.ConstructorArguments[0].Value is INamedTypeSymbol targetType)
                {
                    runsAfter.Add(targetType.ToDisplayString());
                }
            }
        }

        return new SystemInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.ToDisplayString(),
            phase,
            order,
            group,
            runsBefore,
            runsAfter);
    }

    private static string GenerateSystemPartial(SystemInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        StringHelpers.AppendNamespaceDeclaration(sb, info.Namespace);

        var groupStr = info.Group is not null ? $"\"{info.Group}\"" : "null";

        // Generate RunsBefore and RunsAfter arrays using collection expression syntax
        var runsBeforeStr = GenerateTypeArray(info.RunsBefore, useCollectionExpression: true);
        var runsAfterStr = GenerateTypeArray(info.RunsAfter, useCollectionExpression: true);

        // Generate partial with metadata properties
        sb.AppendLine($"partial class {info.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>The execution phase for this system.</summary>");
        sb.AppendLine($"    public static global::KeenEyes.SystemPhase Phase => global::KeenEyes.SystemPhase.{info.Phase};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The execution order within the phase.</summary>");
        sb.AppendLine($"    public static int Order => {info.Order};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>The system group name, if any.</summary>");
        sb.AppendLine($"    public static string? Group => {groupStr};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Systems that this system must run before.</summary>");
        sb.AppendLine($"    public static global::System.Type[] RunsBefore => {runsBeforeStr};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Systems that this system must run after.</summary>");
        sb.AppendLine($"    public static global::System.Type[] RunsAfter => {runsAfterStr};");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateExtensionMethods(SystemInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Use the same namespace as the system for discoverability
        StringHelpers.AppendNamespaceDeclaration(sb, info.Namespace);

        var fullTypeName = StringHelpers.GetFullTypeName(info.Namespace, info.Name);

        // Generate RunsBefore and RunsAfter arrays using explicit array syntax
        var runsBeforeStr = GenerateTypeArray(info.RunsBefore, useCollectionExpression: false);
        var runsAfterStr = GenerateTypeArray(info.RunsAfter, useCollectionExpression: false);

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Extension methods for adding <see cref=\"{info.Name}\"/> to worlds and groups.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public static class {info.Name}Extensions");
        sb.AppendLine("{");

        // World extension method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Adds a <see cref=\"{info.Name}\"/> to the world with its configured phase, order, and dependency constraints.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"world\">The world to add the system to.</param>");
        sb.AppendLine($"    /// <returns>The world for method chaining.</returns>");
        sb.AppendLine($"    /// <remarks>");
        sb.AppendLine($"    /// <para>Phase: <see cref=\"global::KeenEyes.SystemPhase.{info.Phase}\"/></para>");
        sb.AppendLine($"    /// <para>Order: {info.Order}</para>");
        if (info.Group is not null)
        {
            sb.AppendLine($"    /// <para>Group: {info.Group}</para>");
        }
        sb.AppendLine($"    /// </remarks>");
        sb.AppendLine($"    public static global::KeenEyes.World Add{info.Name}(this global::KeenEyes.World world)");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        return world.AddSystem<{fullTypeName}>(");
        sb.AppendLine($"            global::KeenEyes.SystemPhase.{info.Phase},");
        sb.AppendLine($"            order: {info.Order},");
        sb.AppendLine($"            runsBefore: {runsBeforeStr},");
        sb.AppendLine($"            runsAfter: {runsAfterStr});");
        sb.AppendLine($"    }}");
        sb.AppendLine();

        // SystemGroup extension method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Adds a <see cref=\"{info.Name}\"/> to the system group with its configured order.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"group\">The system group to add the system to.</param>");
        sb.AppendLine($"    /// <returns>The system group for method chaining.</returns>");
        sb.AppendLine($"    /// <remarks>");
        sb.AppendLine($"    /// <para>Order: {info.Order}</para>");
        sb.AppendLine($"    /// </remarks>");
        sb.AppendLine($"    public static global::KeenEyes.SystemGroup Add{info.Name}(this global::KeenEyes.SystemGroup group)");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        return group.Add<{fullTypeName}>(order: {info.Order});");
        sb.AppendLine($"    }}");

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates a type array literal from a list of type names.
    /// </summary>
    /// <param name="types">The list of fully qualified type names.</param>
    /// <param name="useCollectionExpression">If true, uses [] syntax; otherwise uses new Type[] { } syntax.</param>
    /// <returns>The generated type array literal.</returns>
    private static string GenerateTypeArray(List<string> types, bool useCollectionExpression)
    {
        if (types.Count == 0)
        {
            return useCollectionExpression ? "[]" : "global::System.Array.Empty<global::System.Type>()";
        }

        var typeofs = string.Join(", ", types.Select(t => $"typeof(global::{t})"));
        return useCollectionExpression
            ? $"[{typeofs}]"
            : $"new global::System.Type[] {{ {typeofs} }}";
    }

    private enum SystemPhase
    {
        EarlyUpdate,
        FixedUpdate,
        Update,
        LateUpdate,
        Render,
        PostRender
    }

    private sealed record SystemInfo(
        string Name,
        string Namespace,
        string FullName,
        SystemPhase Phase,
        int Order,
        string? Group,
        List<string> RunsBefore,
        List<string> RunsAfter);
}
