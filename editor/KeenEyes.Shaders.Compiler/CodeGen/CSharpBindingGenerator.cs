using System.Text;
using KeenEyes.Shaders.Compiler.Parsing.Ast;

namespace KeenEyes.Shaders.Compiler.CodeGen;

/// <summary>
/// Generates C# binding code for KESL compute shaders.
/// </summary>
public sealed class CSharpBindingGenerator
{
    private readonly StringBuilder _sb = new();
    private int _indent;

    /// <summary>
    /// Gets or sets the namespace for generated code.
    /// </summary>
    public string Namespace { get; set; } = "Generated";

    /// <summary>
    /// Generates C# binding code for a compute shader declaration.
    /// </summary>
    /// <param name="compute">The compute shader AST.</param>
    /// <returns>The generated C# code.</returns>
    public string Generate(ComputeDeclaration compute)
    {
        _sb.Clear();
        _indent = 0;

        // File header
        AppendLine("// <auto-generated>");
        AppendLine("// This code was generated by the KESL compiler.");
        AppendLine("// Do not modify this file directly.");
        AppendLine("// </auto-generated>");
        AppendLine();
        AppendLine("#nullable enable");
        AppendLine();

        // Usings
        AppendLine("using System;");
        AppendLine("using KeenEyes;");
        AppendLine("using KeenEyes.Shaders;");
        AppendLine();

        // Namespace
        AppendLine($"namespace {Namespace};");
        AppendLine();

        // Class declaration
        var className = $"{compute.Name}Shader";
        AppendLine($"/// <summary>");
        AppendLine($"/// GPU compute system for {compute.Name}.");
        AppendLine($"/// </summary>");
        AppendLine($"public sealed partial class {className} : IGpuComputeSystem, IDisposable");
        AppendLine("{");
        _indent++;

        // Fields
        GenerateFields(compute);
        AppendLine();

        // Query descriptor
        GenerateQueryDescriptor(compute);
        AppendLine();

        // Constructor
        GenerateConstructor(compute, className);
        AppendLine();

        // Execute method
        GenerateExecuteMethod(compute);
        AppendLine();

        // Dispose method
        GenerateDisposeMethod(compute);

        _indent--;
        AppendLine("}");

        return _sb.ToString();
    }

    private void GenerateFields(ComputeDeclaration compute)
    {
        AppendLine("private readonly IGpuDevice _device;");
        AppendLine("private readonly CompiledShader _shader;");

        // Generate buffer fields for each component binding
        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            AppendLine($"private GpuBuffer<{binding.ComponentName}>? _{ToCamelCase(binding.ComponentName)}Buffer;");
        }
    }

    private void GenerateQueryDescriptor(ComputeDeclaration compute)
    {
        AppendLine("/// <summary>");
        AppendLine("/// The query descriptor matching the shader's component requirements.");
        AppendLine("/// </summary>");
        Append(GenerateIndent());
        _sb.Append("private static readonly QueryDescriptor Query = QueryDescriptor.Create()");

        foreach (var binding in compute.Query.Bindings)
        {
            switch (binding.AccessMode)
            {
                case AccessMode.Read:
                case AccessMode.Write:
                    _sb.AppendLine();
                    Append(GenerateIndent());
                    _sb.Append($"    .With<{binding.ComponentName}>()");
                    break;
                case AccessMode.Optional:
                    _sb.AppendLine();
                    Append(GenerateIndent());
                    _sb.Append($"    .WithOptional<{binding.ComponentName}>()");
                    break;
                case AccessMode.Without:
                    _sb.AppendLine();
                    Append(GenerateIndent());
                    _sb.Append($"    .Without<{binding.ComponentName}>()");
                    break;
            }
        }

        _sb.AppendLine(";");
    }

    private void GenerateConstructor(ComputeDeclaration compute, string className)
    {
        AppendLine("/// <summary>");
        AppendLine($"/// Creates a new {className} instance.");
        AppendLine("/// </summary>");
        AppendLine("/// <param name=\"device\">The GPU device to use.</param>");
        AppendLine($"public {className}(IGpuDevice device)");
        AppendLine("{");
        _indent++;
        AppendLine("_device = device ?? throw new ArgumentNullException(nameof(device));");
        AppendLine($"_shader = device.CompileComputeShader(EmbeddedShaders.{compute.Name});");
        _indent--;
        AppendLine("}");
    }

    private void GenerateExecuteMethod(ComputeDeclaration compute)
    {
        // Build method signature
        var parameters = new List<string> { "World world" };
        if (compute.Params != null)
        {
            foreach (var param in compute.Params.Parameters)
            {
                parameters.Add($"{ToCSharpType(param.Type)} {param.Name}");
            }
        }
        var paramString = string.Join(", ", parameters);

        AppendLine("/// <summary>");
        AppendLine("/// Executes the compute shader on all matching entities.");
        AppendLine("/// </summary>");
        AppendLine("/// <param name=\"world\">The world containing entities to process.</param>");
        if (compute.Params != null)
        {
            foreach (var param in compute.Params.Parameters)
            {
                AppendLine($"/// <param name=\"{param.Name}\">Shader parameter.</param>");
            }
        }
        AppendLine($"public void Execute({paramString})");
        AppendLine("{");
        _indent++;

        AppendLine("foreach (var archetype in world.QueryArchetypes(Query))");
        AppendLine("{");
        _indent++;

        AppendLine("int count = archetype.EntityCount;");
        AppendLine("if (count == 0) continue;");
        AppendLine();

        // Get component spans
        var writeBindings = new List<QueryBinding>();
        var readBindings = new List<QueryBinding>();

        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"var {varName}Span = archetype.GetComponentSpan<{binding.ComponentName}>();");

            if (binding.AccessMode == AccessMode.Write)
            {
                writeBindings.Add(binding);
            }
            else
            {
                readBindings.Add(binding);
            }
        }

        AppendLine();

        // Ensure buffer capacity
        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"EnsureBufferCapacity(ref _{varName}Buffer, count);");
        }

        AppendLine();

        // Upload to GPU
        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"_{varName}Buffer!.Upload({varName}Span);");
        }

        AppendLine();

        // Create and execute command buffer
        AppendLine("var cmd = _device.CreateCommandBuffer();");
        AppendLine("cmd.BindComputeShader(_shader);");
        AppendLine();

        // Bind buffers
        int bindingIndex = 0;
        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"cmd.BindBuffer({bindingIndex}, _{varName}Buffer!);");
            bindingIndex++;
        }

        AppendLine();

        // Set uniforms
        if (compute.Params != null)
        {
            foreach (var param in compute.Params.Parameters)
            {
                AppendLine($"cmd.SetUniform(\"{param.Name}\", {param.Name});");
            }
        }
        AppendLine("cmd.SetUniform(\"entityCount\", (uint)count);");

        AppendLine();

        // Dispatch
        AppendLine("cmd.Dispatch((count + 63) / 64, 1, 1);");
        AppendLine("cmd.Execute();");

        AppendLine();

        // Download modified components
        foreach (var binding in writeBindings)
        {
            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"_{varName}Buffer!.Download({varName}Span);");
        }

        _indent--;
        AppendLine("}");

        _indent--;
        AppendLine("}");

        AppendLine();

        // Helper method for buffer capacity
        AppendLine("private void EnsureBufferCapacity<T>(ref GpuBuffer<T>? buffer, int count) where T : unmanaged");
        AppendLine("{");
        _indent++;
        AppendLine("if (buffer == null || buffer.Count < count)");
        AppendLine("{");
        _indent++;
        AppendLine("buffer?.Dispose();");
        AppendLine("buffer = _device.CreateBuffer<T>(count);");
        _indent--;
        AppendLine("}");
        _indent--;
        AppendLine("}");
    }

    private void GenerateDisposeMethod(ComputeDeclaration compute)
    {
        AppendLine("/// <summary>");
        AppendLine("/// Releases GPU resources.");
        AppendLine("/// </summary>");
        AppendLine("public void Dispose()");
        AppendLine("{");
        _indent++;

        foreach (var binding in compute.Query.Bindings)
        {
            if (binding.AccessMode == AccessMode.Without)
            {
                continue;
            }

            var varName = ToCamelCase(binding.ComponentName);
            AppendLine($"_{varName}Buffer?.Dispose();");
        }

        AppendLine("_shader.Dispose();");

        _indent--;
        AppendLine("}");
    }

    private static string ToCSharpType(TypeRef type)
    {
        if (type is PrimitiveType pt)
        {
            return pt.Kind switch
            {
                PrimitiveTypeKind.Float => "float",
                PrimitiveTypeKind.Float2 => "System.Numerics.Vector2",
                PrimitiveTypeKind.Float3 => "System.Numerics.Vector3",
                PrimitiveTypeKind.Float4 => "System.Numerics.Vector4",
                PrimitiveTypeKind.Int => "int",
                PrimitiveTypeKind.Int2 => "(int, int)",
                PrimitiveTypeKind.Int3 => "(int, int, int)",
                PrimitiveTypeKind.Int4 => "(int, int, int, int)",
                PrimitiveTypeKind.Uint => "uint",
                PrimitiveTypeKind.Bool => "bool",
                PrimitiveTypeKind.Mat4 => "System.Numerics.Matrix4x4",
                _ => throw new ArgumentOutOfRangeException(nameof(type), pt.Kind, "Unsupported primitive type")
            };
        }

        throw new NotSupportedException($"Type {type.GetType().Name} not supported");
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }

#pragma warning disable IDE0057 // Substring can be simplified - not available in netstandard2.0
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
#pragma warning restore IDE0057
    }

    private void AppendLine(string? text = null)
    {
        if (text != null)
        {
            _sb.Append(GenerateIndent());
            _sb.AppendLine(text);
        }
        else
        {
            _sb.AppendLine();
        }
    }

    private void Append(string text)
    {
        _sb.Append(text);
    }

    private string GenerateIndent()
    {
        return new string(' ', _indent * 4);
    }
}
